# -*- coding: utf-8 -*-
"""MRFO algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dVlPGUBVcJGkXv9dHPpryQhOnN0kwuYP

## **SPAERIX INFOTECH**-[Projects](https://sites.google.com/view/spaerixprojects/projects)
"""

# Spaerix infotech - spaerixinfotech@gmail.com
import numpy as np 
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

"""MRFO """

def fun(X):
    output = sum(np.square(X))+random.random()
    return output

# This function is to initialize the  population.
def initial(pop, dim, ub, lb):
    X = np.zeros([pop, dim])
    for i in range(pop):
        for j in range(dim):
            X[i, j] = random.random()*(ub[j] - lb[j]) + lb[j]
    return X

# Calculate fitness values for each population.
def CaculateFitness1(X,fun):
    fitness = fun(X)
    return fitness

# Sort fitness.
def SortFitness(Fit):
    fitness = np.sort(Fit, axis=0)
    index = np.argsort(Fit, axis=0)
    return fitness,index


# Sort the position  according to fitness.
def SortPosition(X,index):
    Xnew = np.zeros(X.shape)
    for i in range(X.shape[0]):
        Xnew[i,:] = X[index[i],:]
    return Xnew


# Boundary detection function.
def BorderCheck1(X,lb,ub,dim):
        for j in range(dim):
            if X[j]<lb[j]:
                X[j] = ub[j]
            elif X[j]>ub[j]:
                X[j] = lb[j]
        return X

def rand_dim(Dim):
  randomlist2=[]
  for i in range(0,Dim):
        n = random.random()
        randomlist2.append(n)
  return randomlist2

def log_random(Dim):
  randomlist3=[]
  for i in range(0,Dim):
        n = random.random()
        nn=-math.log(n)
        randomlist3.append(nn)
  return randomlist3

import random
import time
import math

import numpy as np
rng = np.random.default_rng()
import math
import sys
from numpy import linalg as LA

low = -1
Up = 1
Dim = 34
nPop =10
Max_iter = 300               # Maximum number of iterations.

lb = low*np.ones([Dim, 1])
ub = Up*np.ones([Dim, 1])
X = initial(nPop, Dim, lb,ub)                    # Initialize 
fitness = np.zeros([nPop, 1])
for i in range(nPop):
  fitness[i] = CaculateFitness1(X[i, :], fun)
fitness, sortIndex = SortFitness(fitness)       # Sort the fitness values .
X = SortPosition(X, sortIndex)                  # Sort 
GbestScore = 100000                         # The optimal value for the current iteration.
GbestPositon = np.zeros([1, Dim])
GbestPositon[0, :] = X[0, :]
Curve = np.zeros([Max_iter, 1])
vec_flag=[1,-1]
vec_flag=np.array(vec_flag)
Xnew = np.zeros([nPop, Dim])
ybest=GbestScore 
for it in range (Max_iter):
  coef = it/Max_iter
  Fc=2-it*((2)/Max_iter)
  rr=random.random()
  r5=0.5
  if rr<r5:
    r1=random.random()
    beta = 2*math.exp(r1*((Max_iter-it+1)/Max_iter))*math.sin(2*math.pi*r1)
    if coef>random.random():
      Xnew[0,:]=GbestPositon+rand_dim(Dim)*(GbestPositon-X[0, :])+beta*(GbestPositon-X[0, :])
    else:
      IndivRand = initial(1, Dim, ub, lb)
      #print(IndivRand)
      Xnew[0,:]=IndivRand+rand_dim(Dim)*(IndivRand-X[0, :])+beta*(IndivRand-X[0, :])
  else:
    randomlist2 = np.array(rand_dim(Dim))
    randomlist3=np.array(log_random(Dim))
    r1_soa = random.random()
    r2_soa = random.random()
    A1=2*Fc*r1_soa-Fc
    C1=2*r2_soa
    b=1
    ll=(Fc-1)*random.random()+1
    Alpha = 2*randomlist2*(randomlist3)**0.5
    Xnew[0,:] = X[0, :]+rand_dim(Dim)*(GbestPositon-X[0, :])+Alpha*(GbestPositon-X[0, :]) #
  for i in range(nPop-1):
    rr=random.random()
    if rr<r5:
      r1=random.random()
      beta = 2*math.exp(r1*((Max_iter-it+1)/Max_iter))*math.sin(2*math.pi*r1)
      if coef>random.random():
        Xnew[i+1,:]=GbestPositon+rand_dim(Dim)*(X[i, :]-X[i+1, :])+beta*(GbestPositon-X[i+1, :])
      else:
        IndivRand = initial(1, Dim, ub, lb)
      #print(IndivRand)
        Xnew[0,:]=IndivRand+rand_dim(Dim)*(X[i, :]-X[i+1, :])+beta*(IndivRand-X[i+1, :])
    else:
      randomlist2 = np.array(rand_dim(Dim))
      randomlist3=np.array(log_random(Dim))
      r1_soa = random.random()
      r2_soa = random.random()
      A1=2*Fc*r1_soa-Fc
      C1=2*r2_soa
      b=1
      ll=(Fc-1)*random.random()+1
      Alpha = 2*randomlist2*(randomlist3)**0.5
      Xnew[0,:] = X[i+1, :]+rand_dim(Dim)*(X[i, :]-X[i+1, :])+Alpha*(GbestPositon-X[i+1, :])    
  for i1 in range(nPop):
     Xnew[i1,:] = BorderCheck1(Xnew[i1,:], lb, ub, Dim)
     tempFitness = CaculateFitness1(Xnew[i1,:], fun)     
     if (tempFitness<fitness[i1]):
         fitness[i1] = tempFitness
         X[i1, :] =Xnew[i1,:]

  for i2 in range(nPop):   
     if (fitness[i2] <= GbestScore):       
       GbestScore = fitness[i2]
       GbestPositon =  X[i2,:]
    
  Curve[it] = GbestScore

  
  print('Iteration: ',it)
  print('Best fitness:',Curve[it] )

import matplotlib.pyplot as plt

fig, ax = plt.subplots()
ax.plot( Curve,color='dodgerblue', marker='o', markeredgecolor='k', markerfacecolor='dodgerblue')

ax.set_xlabel('Number of Iterations',fontsize=15)
ax.set_ylabel('Fitness',fontsize=15)
ax.set_title(' Manta Ray Foraging Optimization')
plt.show()